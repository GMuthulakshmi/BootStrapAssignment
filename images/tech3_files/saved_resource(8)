/* Detect-zoom
 * -----------
 * Cross Browser Zoom and Pixel Ratio Detector
 * Version 1.0.4 | Apr 1 2013
 * dual-licensed under the WTFPL and MIT license
 * Maintained by https://github/tombigel
 * Original developer https://github.com/yonran
 */

//AMD and CommonJS initialization copied from https://github.com/zohararad/audio5js
(function (root, ns, factory) {
    "use strict";

    if (typeof (module) !== 'undefined' && module.exports) { // CommonJS
        module.exports = factory(ns, root);
    } else if (typeof (define) === 'function' && define.amd) { // AMD
        define("factory", function () {
            return factory(ns, root);
        });
    } else {
        root[ns] = factory(ns, root);
    }

}(window, 'detectZoom', function () {

    /**
     * Use devicePixelRatio if supported by the browser
     * @return {Number}
     * @private
     */
    var devicePixelRatio = function () {
        return window.devicePixelRatio || 1;
    };

    /**
     * Fallback function to set default values
     * @return {Object}
     * @private
     */
    var fallback = function () {
        return {
            zoom: 1,
            devicePxPerCssPx: 1
        };
    };
    /**
     * IE 8 and 9: no trick needed!
     * TODO: Test on IE10 and Windows 8 RT
     * @return {Object}
     * @private
     **/
    var ie8 = function () {
        var zoom = Math.round((screen.deviceXDPI / screen.logicalXDPI) * 100) / 100;
        return {
            zoom: zoom,
            devicePxPerCssPx: zoom * devicePixelRatio()
        };
    };

    /**
     * For IE10 we need to change our technique again...
     * thanks https://github.com/stefanvanburen
     * @return {Object}
     * @private
     */
    var ie10 = function () {
        var zoom = Math.round((document.documentElement.offsetHeight / window.innerHeight) * 100) / 100;
        return {
            zoom: zoom,
            devicePxPerCssPx: zoom * devicePixelRatio()
        };
    };

    /**
     * Mobile WebKit
     * the trick: window.innerWIdth is in CSS pixels, while
     * screen.width and screen.height are in system pixels.
     * And there are no scrollbars to mess up the measurement.
     * @return {Object}
     * @private
     */
    var webkitMobile = function () {
        var deviceWidth = (Math.abs(window.orientation) == 90) ? screen.height : screen.width;
        var zoom = deviceWidth / window.innerWidth;
        return {
            zoom: zoom,
            devicePxPerCssPx: zoom * devicePixelRatio()
        };
    };

    /**
     * Desktop Webkit
     * the trick: an element's clientHeight is in CSS pixels, while you can
     * set its line-height in system pixels using font-size and
     * -webkit-text-size-adjust:none.
     * device-pixel-ratio: http://www.webkit.org/blog/55/high-dpi-web-sites/
     *
     * Previous trick (used before http://trac.webkit.org/changeset/100847):
     * documentElement.scrollWidth is in CSS pixels, while
     * document.width was in system pixels. Note that this is the
     * layout width of the document, which is slightly different from viewport
     * because document width does not include scrollbars and might be wider
     * due to big elements.
     * @return {Object}
     * @private
     */
    var webkit = function () {
        var important = function (str) {
            return str.replace(/;/g, " !important;");
        };

        var div = document.createElement('div');
        div.innerHTML = "1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>0";
        div.setAttribute('style', important('font: 100px/1em sans-serif; -webkit-text-size-adjust: none; text-size-adjust: none; height: auto; width: 1em; padding: 0; overflow: visible;'));

        // The container exists so that the div will be laid out in its own flow
        // while not impacting the layout, viewport size, or display of the
        // webpage as a whole.
        // Add !important and relevant CSS rule resets
        // so that other rules cannot affect the results.
        var container = document.createElement('div');
        container.setAttribute('style', important('width:0; height:0; overflow:hidden; visibility:hidden; position: absolute;'));
        container.appendChild(div);

        document.body.appendChild(container);
        var zoom = 1000 / div.clientHeight;
        zoom = Math.round(zoom * 100) / 100;
        document.body.removeChild(container);

        return{
            zoom: zoom,
            devicePxPerCssPx: zoom * devicePixelRatio()
        };
    };

    /**
     * no real trick; device-pixel-ratio is the ratio of device dpi / css dpi.
     * (Note that this is a different interpretation than Webkit's device
     * pixel ratio, which is the ratio device dpi / system dpi).
     *
     * Also, for Mozilla, there is no difference between the zoom factor and the device ratio.
     *
     * @return {Object}
     * @private
     */
    var firefox4 = function () {
        var zoom = mediaQueryBinarySearch('min--moz-device-pixel-ratio', '', 0, 10, 20, 0.0001);
        zoom = Math.round(zoom * 100) / 100;
        return {
            zoom: zoom,
            devicePxPerCssPx: zoom
        };
    };

    /**
     * Firefox 18.x
     * Mozilla added support for devicePixelRatio to Firefox 18,
     * but it is affected by the zoom level, so, like in older
     * Firefox we can't tell if we are in zoom mode or in a device
     * with a different pixel ratio
     * @return {Object}
     * @private
     */
    var firefox18 = function () {
        return {
            zoom: firefox4().zoom,
            devicePxPerCssPx: devicePixelRatio()
        };
    };

    /**
     * works starting Opera 11.11
     * the trick: outerWidth is the viewport width including scrollbars in
     * system px, while innerWidth is the viewport width including scrollbars
     * in CSS px
     * @return {Object}
     * @private
     */
    var opera11 = function () {
        var zoom = window.top.outerWidth / window.top.innerWidth;
        zoom = Math.round(zoom * 100) / 100;
        return {
            zoom: zoom,
            devicePxPerCssPx: zoom * devicePixelRatio()
        };
    };

    /**
     * Use a binary search through media queries to find zoom level in Firefox
     * @param property
     * @param unit
     * @param a
     * @param b
     * @param maxIter
     * @param epsilon
     * @return {Number}
     */
    var mediaQueryBinarySearch = function (property, unit, a, b, maxIter, epsilon) {
        var matchMedia;
        var head, style, div;
        if (window.matchMedia) {
            matchMedia = window.matchMedia;
        } else {
            head = document.getElementsByTagName('head')[0];
            style = document.createElement('style');
            head.appendChild(style);

            div = document.createElement('div');
            div.className = 'mediaQueryBinarySearch';
            div.style.display = 'none';
            document.body.appendChild(div);

            matchMedia = function (query) {
                style.sheet.insertRule('@media ' + query + '{.mediaQueryBinarySearch ' + '{text-decoration: underline} }', 0);
                var matched = getComputedStyle(div, null).textDecoration == 'underline';
                style.sheet.deleteRule(0);
                return {matches: matched};
            };
        }
        var ratio = binarySearch(a, b, maxIter);
        if (div) {
            head.removeChild(style);
            document.body.removeChild(div);
        }
        return ratio;

        function binarySearch(a, b, maxIter) {
            var mid = (a + b) / 2;
            if (maxIter <= 0 || b - a < epsilon) {
                return mid;
            }
            var query = "(" + property + ":" + mid + unit + ")";
            if (matchMedia(query).matches) {
                return binarySearch(mid, b, maxIter - 1);
            } else {
                return binarySearch(a, mid, maxIter - 1);
            }
        }
    };

    /**
     * Generate detection function
     * @private
     */
    var detectFunction = (function () {
        var func = fallback;
        //IE8+
        if (!isNaN(screen.logicalXDPI) && !isNaN(screen.systemXDPI)) {
            func = ie8;
        }
        // IE10+ / Touch
        else if (window.navigator.msMaxTouchPoints) {
            func = ie10;
        }
        //Mobile Webkit
        else if ('orientation' in window && typeof document.body.style.webkitMarquee === 'string') {
            func = webkitMobile;
        }
        //WebKit
        else if (typeof document.body.style.webkitMarquee === 'string') {
            func = webkit;
        }
        //Opera
        else if (navigator.userAgent.indexOf('Opera') >= 0) {
            func = opera11;
        }
        //Last one is Firefox
        //FF 18.x
        else if (window.devicePixelRatio) {
            func = firefox18;
        }
        //FF 4.0 - 17.x
        else if (firefox4().zoom > 0.001) {
            func = firefox4;
        }

        return func;
    }());


    return ({

        /**
         * Ratios.zoom shorthand
         * @return {Number} Zoom level
         */
        zoom: function () {
            return detectFunction().zoom;
        },

        /**
         * Ratios.devicePxPerCssPx shorthand
         * @return {Number} devicePxPerCssPx level
         */
        device: function () {
            return detectFunction().devicePxPerCssPx;
        }
    });
}));

var wpcom_img_zoomer = {
	zoomed: false,
	timer: null,
	interval: 1000, // zoom polling interval in millisecond

	// Should we apply width/height attributes to control the image size?
	imgNeedsSizeAtts: function( img ) {
		// Do not overwrite existing width/height attributes.
		if ( img.getAttribute('width') !== null || img.getAttribute('height') !== null )
			return false;
		// Do not apply the attributes if the image is already constrained by a parent element.
		if ( img.width < img.naturalWidth || img.height < img.naturalHeight )
			return false;
		return true;
	},

	init: function() {
		var t = this;
		try{
			t.zoomImages();
			t.timer = setInterval( function() { t.zoomImages(); }, t.interval );
		}
		catch(e){
		}
	},

	stop: function() {
		if ( this.timer )
			clearInterval( this.timer );
	},

	getScale: function() {
		var scale = detectZoom.device();
		// Round up to 1.5 or the next integer below the cap.
		if      ( scale <= 1.0 ) scale = 1.0;
		else if ( scale <= 1.5 ) scale = 1.5;
		else if ( scale <= 2.0 ) scale = 2.0;
		else if ( scale <= 3.0 ) scale = 3.0;
		else if ( scale <= 4.0 ) scale = 4.0;
		else                     scale = 5.0;
		return scale;
	},

	shouldZoom: function( scale ) {
		var t = this;
		// Do not operate on hidden frames.
		if ( "innerWidth" in window && !window.innerWidth )
			return false;
		// Don't do anything until scale > 1
		if ( scale == 1.0 && t.zoomed == false )
			return false;
		return true;
	},

	zoomImages: function() {
		var t = this;
		var scale = t.getScale();
		if ( ! t.shouldZoom( scale ) ){
			return;
		}
		t.zoomed = true;
		// Loop through all the <img> elements on the page.
		var imgs = document.getElementsByTagName("img");

		for ( var i = 0; i < imgs.length; i++ ) {
			// Wait for original images to load
			if ( "complete" in imgs[i] && ! imgs[i].complete )
				continue;

			// For browsers that support srcset and sizes attributes,
			// skip images that have them.
			if ( imgs[i].hasAttribute('srcset') && imgs[i].hasAttribute('sizes') && ( 'sizes' in imgs[i] ) ) {
				continue;
			}

			// Skip images that don't need processing.
			var imgScale = imgs[i].getAttribute("scale");
			if ( imgScale == scale || imgScale == "0" )
				continue;

			// Skip images that have already failed at this scale
			var scaleFail = imgs[i].getAttribute("scale-fail");
			if ( scaleFail && scaleFail <= scale )
				continue;

			// Skip images that have no dimensions yet.
			if ( ! ( imgs[i].width && imgs[i].height ) )
				continue;

			// Skip images from Lazy Load plugins
			if ( ! imgScale && imgs[i].getAttribute("data-lazy-src") && (imgs[i].getAttribute("data-lazy-src") !== imgs[i].getAttribute("src")))
				continue;

			if ( t.scaleImage( imgs[i], scale ) ) {
				// Mark the img as having been processed at this scale.
				imgs[i].setAttribute("scale", scale);
			}
			else {
				// Set the flag to skip this image.
				imgs[i].setAttribute("scale", "0");
			}
		}
	},

	scaleImage: function( img, scale ) {
		var t = this;
		var newSrc = img.src;

		// Skip slideshow images
		if ( img.parentNode.className.match(/slideshow-slide/) )
			return false;

		// Scale gravatars that have ?s= or ?size=
		if ( img.src.match( /^https?:\/\/([^\/]*\.)?gravatar\.com\/.+[?&](s|size)=/ ) ) {
			newSrc = img.src.replace( /([?&](s|size)=)(\d+)/, function( $0, $1, $2, $3 ) {
				// Stash the original size
				var originalAtt = "originals",
				originalSize = img.getAttribute(originalAtt);
				if ( originalSize === null ) {
					originalSize = $3;
					img.setAttribute(originalAtt, originalSize);
					if ( t.imgNeedsSizeAtts( img ) ) {
						// Fix width and height attributes to rendered dimensions.
						img.width = img.width;
						img.height = img.height;
					}
				}
				// Get the width/height of the image in CSS pixels
				var size = img.clientWidth;
				// Convert CSS pixels to device pixels
				var targetSize = Math.ceil(img.clientWidth * scale);
				// Don't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go larger than the service supports
				targetSize = Math.min( targetSize, 512 );
				return $1 + targetSize;
			});
		}

		// Scale resize queries (*.files.wordpress.com) that have ?w= or ?h=
		else if ( img.src.match( /^https?:\/\/([^\/]+)\.files\.wordpress\.com\/.+[?&][wh]=/ ) ) {
			if ( img.src.match( /[?&]crop/ ) )
				return false;
			var changedAttrs = {};
			var matches = img.src.match( /([?&]([wh])=)(\d+)/g );
			for ( var i = 0; i < matches.length; i++ ) {
				var lr = matches[i].split( '=' );
				var thisAttr = lr[0].replace(/[?&]/g, '' );
				var thisVal = lr[1];

				// Stash the original size
				var originalAtt = 'original' + thisAttr, originalSize = img.getAttribute( originalAtt );
				if ( originalSize === null ) {
					originalSize = thisVal;
					img.setAttribute(originalAtt, originalSize);
					if ( t.imgNeedsSizeAtts( img ) ) {
						// Fix width and height attributes to rendered dimensions.
						img.width = img.width;
						img.height = img.height;
					}
				}
				// Get the width/height of the image in CSS pixels
				var size = thisAttr == 'w' ? img.clientWidth : img.clientHeight;
				var naturalSize = ( thisAttr == 'w' ? img.naturalWidth : img.naturalHeight );
				// Convert CSS pixels to device pixels
				var targetSize = Math.ceil(size * scale);
				// Don't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go bigger unless the current one is actually lacking
				if ( scale > img.getAttribute("scale") && targetSize <= naturalSize )
					targetSize = thisVal;
				// Don't try to go bigger if the image is already smaller than was requested
				if ( naturalSize < thisVal )
					targetSize = thisVal;
				if ( targetSize != thisVal )
					changedAttrs[ thisAttr ] = targetSize;
			}
			var w = changedAttrs.w || false;
			var h = changedAttrs.h || false;

			if ( w ) {
				newSrc = img.src.replace(/([?&])w=\d+/g, function( $0, $1 ) {
					return $1 + 'w=' + w;
				});
			}
			if ( h ) {
				newSrc = newSrc.replace(/([?&])h=\d+/g, function( $0, $1 ) {
					return $1 + 'h=' + h;
				});
			}
		}

		// Scale mshots that have width
		else if ( img.src.match(/^https?:\/\/([^\/]+\.)*(wordpress|wp)\.com\/mshots\/.+[?&]w=\d+/) ) {
			newSrc = img.src.replace( /([?&]w=)(\d+)/, function($0, $1, $2) {
				// Stash the original size
				var originalAtt = 'originalw', originalSize = img.getAttribute(originalAtt);
				if ( originalSize === null ) {
					originalSize = $2;
					img.setAttribute(originalAtt, originalSize);
					if ( t.imgNeedsSizeAtts( img ) ) {
						// Fix width and height attributes to rendered dimensions.
						img.width = img.width;
						img.height = img.height;
					}
				}
				// Get the width of the image in CSS pixels
				var size = img.clientWidth;
				// Convert CSS pixels to device pixels
				var targetSize = Math.ceil(size * scale);
				// Don't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go bigger unless the current one is actually lacking
				if ( scale > img.getAttribute("scale") && targetSize <= img.naturalWidth )
					targetSize = $2;
				if ( $2 != targetSize )
					return $1 + targetSize;
				return $0;
			});

			// Update height attribute to match width
			newSrc = newSrc.replace( /([?&]h=)(\d+)/, function($0, $1, $2) {
				if ( newSrc == img.src ) {
					return $0;
				}
				// Stash the original size
				var originalAtt = 'originalh', originalSize = img.getAttribute(originalAtt);
				if ( originalSize === null ) {
					originalSize = $2;
					img.setAttribute(originalAtt, originalSize);
				}
				// Get the height of the image in CSS pixels
				var size = img.clientHeight;
				// Convert CSS pixels to device pixels
				var targetSize = Math.ceil(size * scale);
				// Don't go smaller than the original size
				targetSize = Math.max( targetSize, originalSize );
				// Don't go bigger unless the current one is actually lacking
				if ( scale > img.getAttribute("scale") && targetSize <= img.naturalHeight )
					targetSize = $2;
				if ( $2 != targetSize )
					return $1 + targetSize;
				return $0;
			});
		}

		// Scale simple imgpress queries (s0.wp.com) that only specify w/h/fit
		else if ( img.src.match(/^https?:\/\/([^\/.]+\.)*(wp|wordpress)\.com\/imgpress\?(.+)/) ) {
			var imgpressSafeFunctions = ["zoom", "url", "h", "w", "fit", "filter", "brightness", "contrast", "colorize", "smooth", "unsharpmask"];
			// Search the query string for unsupported functions.
			var qs = RegExp.$3.split('&');
			for ( var q in qs ) {
				q = qs[q].split('=')[0];
				if ( imgpressSafeFunctions.indexOf(q) == -1 ) {
					return false;
				}
			}
			// Fix width and height attributes to rendered dimensions.
			img.width = img.width;
			img.height = img.height;
			// Compute new src
			if ( scale == 1 )
				newSrc = img.src.replace(/\?(zoom=[^&]+&)?/, '?');
			else
				newSrc = img.src.replace(/\?(zoom=[^&]+&)?/, '?zoom=' + scale + '&');
		}

		// Scale LaTeX images or Photon queries (i#.wp.com)
		else if (
			img.src.match(/^https?:\/\/([^\/.]+\.)*(wp|wordpress)\.com\/latex\.php\?(latex|zoom)=(.+)/) ||
			img.src.match(/^https?:\/\/i[\d]{1}\.wp\.com\/(.+)/)
		) {
			// Fix width and height attributes to rendered dimensions.
			img.width = img.width;
			img.height = img.height;
			// Compute new src
			if ( scale == 1 ) {
				newSrc = img.src.replace(/\?(zoom=[^&]+&)?/, '?');
			} else {
				newSrc = img.src;

				var url_var = newSrc.match( /\?w=(\d+)/ );
				if ( url_var !== null && url_var[1] ) {
					newSrc = newSrc.replace( new RegExp( 'w=' + url_var[1] ), 'w=' + img.width );
				}

				url_var = newSrc.match( /\?h=(\d+)/ );
				if ( url_var !== null && url_var[1] ) {
					newSrc = newSrc.replace( new RegExp( 'h=' + url_var[1] ), 'h=' + img.height );
				}

				var zoom_arg = '&zoom=2';
				if ( !newSrc.match( /\?/ ) ) {
					zoom_arg = '?zoom=2';
				}
				img.setAttribute( 'srcset', newSrc + zoom_arg + ' ' + scale + 'x' );
			}
		}

		// Scale static assets that have a name matching *-1x.png or *@1x.png
		else if ( img.src.match(/^https?:\/\/[^\/]+\/.*[-@]([12])x\.(gif|jpeg|jpg|png)(\?|$)/) ) {
			// Fix width and height attributes to rendered dimensions.
			img.width = img.width;
			img.height = img.height;
			var currentSize = RegExp.$1, newSize = currentSize;
			if ( scale <= 1 )
				newSize = 1;
			else
				newSize = 2;
			if ( currentSize != newSize )
				newSrc = img.src.replace(/([-@])[12]x\.(gif|jpeg|jpg|png)(\?|$)/, '$1'+newSize+'x.$2$3');
		}

		else {
			return false;
		}

		// Don't set img.src unless it has changed. This avoids unnecessary reloads.
		if ( newSrc != img.src ) {
			// Store the original img.src
			var prevSrc, origSrc = img.getAttribute("src-orig");
			if ( !origSrc ) {
				origSrc = img.src;
				img.setAttribute("src-orig", origSrc);
			}
			// In case of error, revert img.src
			prevSrc = img.src;
			img.onerror = function(){
				img.src = prevSrc;
				if ( img.getAttribute("scale-fail") < scale )
					img.setAttribute("scale-fail", scale);
				img.onerror = null;
			};
			// Finally load the new image
			img.src = newSrc;
		}

		return true;
	}
};

wpcom_img_zoomer.init();
;
/* global pm, wpcom_reblog */

var jetpackLikesWidgetQueue = [];
var jetpackLikesWidgetBatch = [];
var jetpackLikesMasterReady = false;

function JetpackLikespostMessage( message, target ) {
	if ( 'string' === typeof message ){
		try {
			message = JSON.parse( message );
		} catch(e) {
			return;
		}
	}

	pm( {
		target: target,
		type: 'likesMessage',
		data: message,
		origin: '*'
	} );
}

function JetpackLikesBatchHandler() {
	var requests = [];
	jQuery( 'div.jetpack-likes-widget-unloaded' ).each( function() {
		if ( jetpackLikesWidgetBatch.indexOf( this.id ) > -1 ) {
			return;
		}
		jetpackLikesWidgetBatch.push( this.id );
		var regex = /like-(post|comment)-wrapper-(\d+)-(\d+)-(\w+)/,
			match = regex.exec( this.id ),
			info;

		if ( ! match || match.length !== 5 ) {
			return;
		}

		info = {
			blog_id: match[2],
			width:   this.width
		};

		if ( 'post' === match[1] ) {
			info.post_id = match[3];
		} else if ( 'comment' === match[1] ) {
			info.comment_id = match[3];
		}

		info.obj_id = match[4];

		requests.push( info );
	});

	if ( requests.length > 0 ) {
		JetpackLikespostMessage( { event: 'initialBatch', requests: requests }, window.frames['likes-master'] );
	}
}

function JetpackLikesMessageListener( event, message ) {
	var allowedOrigin, $container, $list, offset, rowLength, height, scrollbarWidth;

	if ( 'undefined' === typeof event.event ) {
		return;
	}

	// We only allow messages from one origin
	allowedOrigin = window.location.protocol + '//widgets.wp.com';
	if ( allowedOrigin !== message.origin ) {
		return;
	}

	if ( 'masterReady' === event.event ) {
		jQuery( document ).ready( function() {
			jetpackLikesMasterReady = true;

			var stylesData = {
					event: 'injectStyles'
				},
				$sdTextColor = jQuery( '.sd-text-color' ),
				$sdLinkColor = jQuery( '.sd-link-color' );

			if ( jQuery( 'iframe.admin-bar-likes-widget' ).length > 0 ) {
				JetpackLikespostMessage( { event: 'adminBarEnabled' }, window.frames[ 'likes-master' ] );

				stylesData.adminBarStyles = {
					background: jQuery( '#wpadminbar .quicklinks li#wp-admin-bar-wpl-like > a' ).css( 'background' ),
					isRtl: ( 'rtl' === jQuery( '#wpadminbar' ).css( 'direction' ) )
				};
			}

			if ( ! window.addEventListener ) {
				jQuery( '#wp-admin-bar-admin-bar-likes-widget' ).hide();
			}

			stylesData.textStyles = {
				color:          $sdTextColor.css( 'color' ),
				fontFamily:     $sdTextColor.css( 'font-family' ),
				fontSize:       $sdTextColor.css( 'font-size' ),
				direction:      $sdTextColor.css( 'direction' ),
				fontWeight:     $sdTextColor.css( 'font-weight' ),
				fontStyle:      $sdTextColor.css( 'font-style' ),
				textDecoration: $sdTextColor.css('text-decoration')
			};

			stylesData.linkStyles = {
				color:          $sdLinkColor.css('color'),
				fontFamily:     $sdLinkColor.css('font-family'),
				fontSize:       $sdLinkColor.css('font-size'),
				textDecoration: $sdLinkColor.css('text-decoration'),
				fontWeight:     $sdLinkColor.css( 'font-weight' ),
				fontStyle:      $sdLinkColor.css( 'font-style' )
			};

			JetpackLikespostMessage( stylesData, window.frames[ 'likes-master' ] );

			JetpackLikesBatchHandler();

			jQuery( document ).on( 'inview', 'div.jetpack-likes-widget-unloaded', function() {
				jetpackLikesWidgetQueue.push( this.id );
			});
		});
	}

	if ( 'showLikeWidget' === event.event ) {
		jQuery( '#' + event.id + ' .post-likes-widget-placeholder'  ).fadeOut( 'fast', function() {
			jQuery( '#' + event.id + ' .post-likes-widget' ).fadeIn( 'fast', function() {
				JetpackLikespostMessage( { event: 'likeWidgetDisplayed', blog_id: event.blog_id, post_id: event.post_id, obj_id: event.obj_id }, window.frames['likes-master'] );
			});
		});
	}

	if ( 'clickReblogFlair' === event.event ) {
		wpcom_reblog.toggle_reblog_box_flair( event.obj_id );
	}

	if ( 'showOtherGravatars' === event.event ) {
		$container = jQuery( '#likes-other-gravatars' );
		$list = $container.find( 'ul' );

		$container.hide();
		$list.html( '' );

		$container.find( '.likes-text span' ).text( event.total );

		jQuery.each( event.likers, function( i, liker ) {
			var element = jQuery( '<li><a><img /></a></li>' );
			element.addClass( liker.css_class );

			element.find( 'a' ).
				attr({
					href: liker.profile_URL,
					rel: 'nofollow',
					target: '_parent'
				}).
				addClass( 'wpl-liker' );

			element.find( 'img' ).
				attr({
					src: liker.avatar_URL,
					alt: liker.name
				}).
				css({
					width: '30px',
					height: '30px',
					paddingRight: '3px'
				});

			$list.append( element );
		} );

		offset = jQuery( '[name=\'' + event.parent + '\']' ).offset();

		$container.css( 'left', offset.left + event.position.left - 10 + 'px' );
		$container.css( 'top', offset.top + event.position.top - 33 + 'px' );

		rowLength = Math.floor( event.width / 37 );
		height = ( Math.ceil( event.likers.length / rowLength ) * 37 ) + 13;
		if ( height > 204 ) {
			height = 204;
		}

		$container.css( 'height', height + 'px' );
		$container.css( 'width', rowLength * 37 - 7 + 'px' );

		$list.css( 'width', rowLength * 37 + 'px' );

		$container.fadeIn( 'slow' );

		scrollbarWidth = $list[0].offsetWidth - $list[0].clientWidth;
		if ( scrollbarWidth > 0 ) {
			$container.width( $container.width() + scrollbarWidth );
			$list.width( $list.width() + scrollbarWidth );
		}
	}
}

pm.bind( 'likesMessage', JetpackLikesMessageListener );

jQuery( document ).click( function( e ) {
	var $container = jQuery( '#likes-other-gravatars' );

	if ( $container.has( e.target ).length === 0 ) {
		$container.fadeOut( 'slow' );
	}
});

function JetpackLikesWidgetQueueHandler() {
	var $wrapper, wrapperID, found;
	if ( ! jetpackLikesMasterReady ) {
		setTimeout( JetpackLikesWidgetQueueHandler, 500 );
		return;
	}

	if ( jetpackLikesWidgetQueue.length > 0 ) {
		// We may have a widget that needs creating now
		found = false;
		while( jetpackLikesWidgetQueue.length > 0 ) {
			// Grab the first member of the queue that isn't already loading.
			wrapperID = jetpackLikesWidgetQueue.splice( 0, 1 )[0];
			if ( jQuery( '#' + wrapperID ).hasClass( 'jetpack-likes-widget-unloaded' ) ) {
				found = true;
				break;
			}
		}
		if ( ! found ) {
			setTimeout( JetpackLikesWidgetQueueHandler, 500 );
			return;
		}
	} else if ( jQuery( 'div.jetpack-likes-widget-unloaded' ).length > 0 ) {
		// Grab any unloaded widgets for a batch request
		JetpackLikesBatchHandler();

		// Get the next unloaded widget
		wrapperID = jQuery( 'div.jetpack-likes-widget-unloaded' ).first()[0].id;
		if ( ! wrapperID ) {
			// Everything is currently loaded
			setTimeout( JetpackLikesWidgetQueueHandler, 500 );
			return;
		}
	}

	if ( 'undefined' === typeof wrapperID ) {
		setTimeout( JetpackLikesWidgetQueueHandler, 500 );
		return;
	}

	$wrapper = jQuery( '#' + wrapperID );
	$wrapper.find( 'iframe' ).remove();

	if ( $wrapper.hasClass( 'slim-likes-widget' ) ) {
		$wrapper.find( '.post-likes-widget-placeholder' ).after( '<iframe class="post-likes-widget jetpack-likes-widget" name="' + $wrapper.data( 'name' ) + '" height="22px" width="68px" frameBorder="0" scrolling="no" src="' + $wrapper.data( 'src' ) + '"></iframe>' );
	} else {
		$wrapper.find( '.post-likes-widget-placeholder' ).after( '<iframe class="post-likes-widget jetpack-likes-widget" name="' + $wrapper.data( 'name' ) + '" height="55px" width="100%" frameBorder="0" src="' + $wrapper.data( 'src' ) + '"></iframe>' );
	}

	$wrapper.removeClass( 'jetpack-likes-widget-unloaded' ).addClass( 'jetpack-likes-widget-loading' );

	$wrapper.find( 'iframe' ).load( function( e ) {
		var $iframe = jQuery( e.target );
		$wrapper.removeClass( 'jetpack-likes-widget-loading' ).addClass( 'jetpack-likes-widget-loaded' );

		JetpackLikespostMessage( { event: 'loadLikeWidget', name: $iframe.attr( 'name' ), width: $iframe.width() }, window.frames[ 'likes-master' ] );

		if ( $wrapper.hasClass( 'slim-likes-widget' ) ) {
			$wrapper.find( 'iframe' ).Jetpack( 'resizeable' );
		}
	});
	setTimeout( JetpackLikesWidgetQueueHandler, 250 );
}
JetpackLikesWidgetQueueHandler();
;
// JavaScript Document
jQuery(document).ready(function(){

// techie menu
	jQuery('.hamburber_icon').click(function(){
				jQuery('#mobnav').slideToggle();
				return false;
	});
	
	var win = jQuery(window).width();
	if(win < 767 ){
		jQuery('i.fa.fa-search').click(function(){
		jQuery(this).parent().find('input[type="text"],input[type="submit"]').toggle();
	});
	}

// menu dropdown strat
jQuery('li.mainnav').click(function(){ 
		jQuery(this).children('a#menu').hide();
		jQuery(this).children('a#menuclose').show();
		jQuery('.menu-sub').slideDown(300);
				
});
jQuery('#navnext').click(function(){
			jQuery('.first-menu ul').animate({top : '-=175'});
			jQuery(this).hide()
			jQuery('#navprev').show()
		})
jQuery('#navprev').click(function(){
			jQuery('.first-menu ul').animate({top : '+=175'});
			jQuery(this).hide()
			jQuery('#navnext').show()
		})

jQuery('a#menuclose').click(function(){
		jQuery('.menu-sub').slideUp(500);
		jQuery('a#menu').show();
		jQuery(this).hide();
		return false;
});

// menu dropdown END
// Trending JS

//group link js
jQuery('li.grouplinks a#menu_h').click(function() {
	jQuery('.menu-sub').slideUp(500);
	jQuery('a#menu').show();
	jQuery('a#menuclose').hide();
	jQuery(this).parent('li.grouplinks').toggleClass('active')
	jQuery('.right_t_menu').slideToggle(500);
});	


jQuery('.right_t_menu').mouseleave(function(){
	jQuery(this).slideUp(500);
	jQuery('.navi li.grouplinks').removeClass('active');
});

jQuery('.tabs .tab-links a').on('click', function(e)  {
				var currentAttrValue = jQuery(this).attr('href');

				// Show/Hide Tabs
				jQuery('.tabs ' + currentAttrValue).show().siblings().hide();

				// Change/remove current tab to active
				jQuery(this).parent('li').addClass('active').siblings().removeClass('active');

				e.preventDefault();
		});
	var hei = jQuery('.hdr').height();
	jQuery('div[class ="add-left"],div[class ="add-right"]').css('top','195px');
	jQuery(window).scroll(function(){
		var scr = jQuery(window).scrollTop();
		if(scr > hei){
			jQuery('div[class ="add-left"],div[class ="add-right"]').css('top','5px');
		}
		else{
			jQuery('div[class ="add-left"],div[class ="add-right"]').css('top','195px');
		}
	})
	
	jQuery(window).scroll(function (event) {
		var top = parseInt(jQuery('#fixedMenu').offset().top);
		var y = jQuery(this).scrollTop();
		if (y >= top) {
			jQuery('#fixedMenu').addClass('fixed');
			jQuery("#fixedMenu").fadeIn();
		} else if(y < top){
			jQuery('#fixedMenu').removeClass('fixed');	
		}
	});
	
	if( jQuery(window).scrollTop() >= 500 ){
		jQuery(window).trigger('scroll');
	}

});


// Drow Down Menu on 1024 Resolutions
jQuery(function() {
	jQuery(window).resize(function(){
		try{
			var w = jQuery(window).width();
			if(w > 1024 && menu.is(':hidden')) {
				menu.removeAttr('style');
			}
		}catch(err){}
	});
});
		
// Guggter Space ADD Code and Social Icons on Mouse hover
jQuery(document).ready(function(){
		try{
	if ( jQuery('#wpadminbar') != null && jQuery('#wpadminbar').length > 0 ) {
			  jQuery('.top-menu').css({ 'top': '32px'  });
		}
		else {
			  jQuery('.top-menu').css({ 'top': '0px'  });
		}


		var w_width = jQuery(window).width();
		if (w_width <= 1280)
		{
			jQuery('.left-ad, .right-ad').hide();
			jQuery('#storycenterbyline').show();
		}
		if( page_type == 'story' ){
			var advt = jQuery('.add-left, .add-right').html();
			if(advt == null || advt == undefined || advt.trim() == "") {
				jQuery('.left-ad, .right-ad').hide();
			}
			else
			{
				jQuery('#storycenterbyline').show();
			}
		}

		/* Social Icons */
		jQuery('.fbbx').hover(function(){jQuery('.face').slideToggle(100);});
		jQuery('.twitbx').hover(function(){jQuery('.twitbxh').slideToggle(100);});
		jQuery('.gplusbx').hover(function(){jQuery('.gplusbxh').slideToggle(100);});
	}
	catch(err){}
});


/* Previous Next Story */
jQuery(function () {
jQuery('#pre-story').mouseover(function () {
  jQuery('.one').css("display", "block");
});
  jQuery('#pre-story').mouseout(function () {
  jQuery('.one').css("display", "none");
});

jQuery('#next-story').mouseover(function () {
  jQuery('.two').css("display", "block");
});
  jQuery('#next-story').mouseout(function () {
  jQuery('.two').css("display", "none");
});
});

/* Previous Next Story and Breaking Hide*/
jQuery(document).ready(function(){
jQuery(".icons-share").hide();
jQuery('.share').click(function () {
jQuery('.icons-share').slideToggle(100);
});

jQuery('.search').click(function () {
	jQuery('.form').slideToggle();
});

jQuery('.close').click(function () {
	jQuery('.breaking').hide();
});

//jQuery('.button').click(function () {
//  jQuery('#main').hide({width: 'toggle'});
//});

});


/* Breaking News Display*/
function ticker() {
		jQuery('#news li:first').slideUp(function() {
		jQuery(this).appendTo(jQuery('#news')).slideDown();
});
}
setInterval(ticker, 6000);


// Video Custom Scroll ///////////////////////////////////

(function($) {

jQuery.fn.extend({
slimScroll: function(options) {

  var defaults = {

	// width in pixels of the visible scroll area
	width : 'auto',

	// height in pixels of the visible scroll area
	height : '120px',

	// width in pixels of the scrollbar and rail
	size : '5px',

	// scrollbar color, accepts any hex/color value
	color: '#a1a1a1',

	// scrollbar position - left/right
	position : 'left',

	// distance in pixels between the side edge and the scrollbar
	distance : '1px',

	// default scroll position on load - top / bottom / $('selector')
	start : 'top',

	// sets scrollbar opacity
	opacity : 1,

	// enables always-on mode for the scrollbar
	alwaysVisible : true,

	// check if we should hide the scrollbar when user is hovering over
	disableFadeOut : false,

	// sets visibility of the rail
	railVisible : false,

	// sets rail color
	railColor : '#333',

	// sets rail opacity
	railOpacity : 1,

	// whether  we should use jQuery UI Draggable to enable bar dragging
	railDraggable : true,

	// defautlt CSS class of the slimscroll rail
	railClass : 'slimScrollRail',

	// defautlt CSS class of the slimscroll bar
	barClass : 'slimScrollBar',

	// defautlt CSS class of the slimscroll wrapper
	wrapperClass : 'slimScroll',

	// check if mousewheel should scroll the window if we reach top/bottom
	allowPageScroll : false,

	// scroll amount applied to each mouse wheel step
	wheelStep : 1,

	// scroll amount applied when user is using gestures
	touchScrollStep : 400,

	// sets border radius
	borderRadius: '7px',

	// sets border radius of the rail
	railBorderRadius : '7px'
  };

  var o = $.extend(defaults, options);

  // do it for every element that matches selector
  this.each(function(){

  var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
	barHeight, percentScroll, lastScroll,
	divS = '<div></div>',
	minBarHeight = 30,
	releaseScroll = false;

	// used in event handlers and for better minification
	var me = $(this);

	// ensure we are not binding it again
	if (me.parent().hasClass(o.wrapperClass))
	{
		// start from last bar position
		var offset = me.scrollTop();

		// find bar and rail
		bar = me.parent().find('.' + o.barClass);
		rail = me.parent().find('.' + o.railClass);

		getBarHeight();

		// check if we should scroll existing instance
		if ($.isPlainObject(options))
		{
		  // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
		  if ( 'height' in options && options.height == 'auto' ) {
			me.parent().css('height', 'auto');
			me.css('height', 'auto');
			var height = me.parent().parent().height();
			me.parent().css('height', height);
			me.css('height', height);
		  }

		  if ('scrollTo' in options)
		  {
			// jump to a static point
			offset = parseInt(o.scrollTo);
		  }
		  else if ('scrollBy' in options)
		  {
			// jump by value pixels
			offset += parseInt(o.scrollBy);
		  }
		  else if ('destroy' in options)
		  {
			// remove slimscroll elements
			bar.remove();
			rail.remove();
			me.unwrap();
			return;
		  }

		  // scroll content by the given offset
		  scrollContent(offset, false, true);
		}

		return;
	}

	// optionally set height to the parent's height
	o.height = (o.height == 'auto') ? me.parent().height() : o.height;

	// wrap content
	var wrapper = $(divS)
	  .addClass(o.wrapperClass)
	  .css({
		position: 'relative',
		overflow: 'hidden',
		width: o.width,
		height: o.height
	  });

	// update style for the div
	me.css({
	  overflow: 'hidden',
	  width: o.width,
	  height: o.height
	});

	// create scrollbar rail
	var rail = $(divS)
	  .addClass(o.railClass)
	  .css({
		width: o.size,
		height: '100%',
		position: 'absolute',
		top: 0,
		display: (o.alwaysVisible && o.railVisible) ? 'block' : 'none',
		'border-radius': o.railBorderRadius,
		background: o.railColor,
		opacity: o.railOpacity,
		zIndex: 90
	  });

	// create scrollbar
	var bar = $(divS)
	  .addClass(o.barClass)
	  .css({
		background: o.color,
		width: o.size,
		position: 'absolute',
		top: 0,
		opacity: o.opacity,
		display: o.alwaysVisible ? 'block' : 'none',
		'border-radius' : o.borderRadius,
		BorderRadius: o.borderRadius,
		MozBorderRadius: o.borderRadius,
		WebkitBorderRadius: o.borderRadius,
		zIndex: 99
	  });

	// set position
	var posCss = (o.position == 'right') ? { right: o.distance } : { left: o.distance };
	rail.css(posCss);
	bar.css(posCss);

	// wrap it
	me.wrap(wrapper);

	// append to parent div
	me.parent().append(bar);
	me.parent().append(rail);

	// make it draggable and no longer dependent on the jqueryUI
	if (o.railDraggable){
	  bar.bind("mousedown", function(e) {
		var $doc = $(document);
		isDragg = true;
		t = parseFloat(bar.css('top'));
		pageY = e.pageY;

		$doc.bind("mousemove.slimscroll", function(e){
		  currTop = t + e.pageY - pageY;
		  bar.css('top', currTop);
		  scrollContent(0, bar.position().top, false);// scroll content
		});

		$doc.bind("mouseup.slimscroll", function(e) {
		  isDragg = false;hideBar();
		  $doc.unbind('.slimscroll');
		});
		return false;
	  }).bind("selectstart.slimscroll", function(e){
		e.stopPropagation();
		e.preventDefault();
		return false;
	  });
	}

	// on rail over
	rail.hover(function(){
	  showBar();
	}, function(){
	  hideBar();
	});

	// on bar over
	bar.hover(function(){
	  isOverBar = true;
	}, function(){
	  isOverBar = false;
	});

	// show on parent mouseover
	me.hover(function(){
	  isOverPanel = true;
	  showBar();
	  hideBar();
	}, function(){
	  isOverPanel = false;
	  hideBar();
	});

	// support for mobile
	me.bind('touchstart', function(e,b){
	  if (e.originalEvent.touches.length)
	  {
		// record where touch started
		touchDif = e.originalEvent.touches[0].pageY;
	  }
	});

	me.bind('touchmove', function(e){
	  // prevent scrolling the page if necessary
	  if(!releaseScroll)
	  {
		  e.originalEvent.preventDefault();
		  }
	  if (e.originalEvent.touches.length)
	  {
		// see how far user swiped
		var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
		// scroll content
		scrollContent(diff, true);
		touchDif = e.originalEvent.touches[0].pageY;
	  }
	});

	// set up initial height
	getBarHeight();

	// check start position
	if (o.start === 'bottom')
	{
	  // scroll content to bottom
	  bar.css({ top: me.outerHeight() - bar.outerHeight() });
	  scrollContent(0, true);
	}
	else if (o.start !== 'top')
	{
	  // assume jQuery selector
	  scrollContent($(o.start).position().top, null, true);

	  // make sure bar stays hidden
	  if (!o.alwaysVisible) { bar.hide(); }
	}

	// attach scroll events
	attachWheel();

	function _onWheel(e)
	{
	  // use mouse wheel only when mouse is over
	  if (!isOverPanel) { return; }

	  var e = e || window.event;

	  var delta = 0;
	  if (e.wheelDelta) { delta = -e.wheelDelta/120; }
	  if (e.detail) { delta = e.detail / 3; }

	  var target = e.target || e.srcTarget || e.srcElement;
	  if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {
		// scroll content
		scrollContent(delta, true);
	  }

	  // stop window scroll
	  if (e.preventDefault && !releaseScroll) { e.preventDefault(); }
	  if (!releaseScroll) { e.returnValue = false; }
	}

	function scrollContent(y, isWheel, isJump)
	{
	  releaseScroll = false;
	  var delta = y;
	  var maxTop = me.outerHeight() - bar.outerHeight();

	  if (isWheel)
	  {
		// move bar with mouse wheel
		delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();

		// move bar, make sure it doesn't go out
		delta = Math.min(Math.max(delta, 0), maxTop);

		// if scrolling down, make sure a fractional change to the
		// scroll position isn't rounded away when the scrollbar's CSS is set
		// this flooring of delta would happened automatically when
		// bar.css is set below, but we floor here for clarity
		delta = (y > 0) ? Math.ceil(delta) : Math.floor(delta);

		// scroll the scrollbar
		bar.css({ top: delta + 'px' });
	  }

	  // calculate actual scroll amount
	  percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());
	  delta = percentScroll * (me[0].scrollHeight - me.outerHeight());

	  if (isJump)
	  {
		delta = y;
		var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
		offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
		bar.css({ top: offsetTop + 'px' });
	  }

	  // scroll content
	  me.scrollTop(delta);

	  // fire scrolling event
	  me.trigger('slimscrolling', ~~delta);

	  // ensure bar is visible
	  showBar();

	  // trigger hide when scroll is stopped
	  hideBar();
	}

	function attachWheel()
	{
	  if (window.addEventListener)
	  {
		this.addEventListener('DOMMouseScroll', _onWheel, false );
		this.addEventListener('mousewheel', _onWheel, false );
		this.addEventListener('MozMousePixelScroll', _onWheel, false );
	  }
	  else
	  {
		document.attachEvent("onmousewheel", _onWheel)
	  }
	}

	function getBarHeight()
	{
	  // calculate scrollbar height and make sure it is not too small
	  barHeight = Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
	  bar.css({ height: barHeight + 'px' });

	  // hide scrollbar if content is not long enough
	  var display = barHeight == me.outerHeight() ? 'none' : 'block';
	  bar.css({ display: display });
	}

	function showBar()
	{
	  // recalculate bar height
	  getBarHeight();
	  clearTimeout(queueHide);

	  // when bar reached top or bottom
	  if (percentScroll == ~~percentScroll)
	  {
		//release wheel
		releaseScroll = o.allowPageScroll;

		// publish approporiate event
		if (lastScroll != percentScroll)
		{
			var msg = (~~percentScroll == 0) ? 'top' : 'bottom';
			me.trigger('slimscroll', msg);
		}
	  }
	  else
	  {
		releaseScroll = false;
	  }
	  lastScroll = percentScroll;

	  // show only when required
	  if(barHeight >= me.outerHeight()) {
		//allow window scroll
		releaseScroll = true;
		return;
	  }
	  bar.stop(true,true).fadeIn('fast');
	  if (o.railVisible) { rail.stop(true,true).fadeIn('fast'); }
	}

	function hideBar()
	{
	  // only hide when options allow it
	  if (!o.alwaysVisible)
	  {
		queueHide = setTimeout(function(){
		  if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg)
		  {
			bar.fadeOut('slow');
			rail.fadeOut('slow');
		  }
		}, 1000);
	  }
	}

  });

  // maintain chainability
  return this;
}
});

jQuery.fn.extend({
slimscroll: jQuery.fn.slimScroll
});

})(jQuery);

jQuery(document).ready(function(){
jQuery('#infoscroll').slimScroll({  height : '120px'});
});;
jQuery(document).ready(function() {
	jQuery(".breaking").bxSlider({auto: true, autoControls: true, autoControlsCombine: true})
	jQuery(".icon-closebtn").click(function() {jQuery(".breaking-news").hide()});
});;
